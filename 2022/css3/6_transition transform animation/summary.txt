
★transform: none'd| rotate?translate?scale|X?Y?Z?3d() skew?X?Y() matrix?3d() perspective();
  ›unapply to unReplaced-i & table-column|-group els.
  ›functions executed by #order, subsequence functions apply to main-axis of #transformed-box(not origin-box).
  ›el:statePseudoClass{#t:required reset all el{t:functions()}}

 *2Dimensions: •rotate?Z(<angle>);
    ›t-origin: <bg-position≠offset>(50% 50%'d→border-box);
  •translate(x'y=0|x,y)|X(x)|Y(y); ›x?y: ±length0d|±%'border-box
  •scale(x=y=±#1d|x,y)|X(x)|Y(y); ›#€-1~1: shrink, else grow.
    ›-#→pointReflection,-x:e→9, -y:e→6, -x=-y:6→9'rotate(.5turn)
  •skew(x'y=0|x,y)|X(x)|Y(y); ›x?y: <angle>.

 *3Dimensions: •demo: #parent{
     perspective: none'd|length'z0→eye; /*create shared 3Dview*/
     perspective-origin: <bg-position>;/*shared 3DviewPosition*/
     t-style: flat'd| preserve-3d;         /*enable 3d nesting*/
    .t-Child{ position: absolute;          /*enable 3d nesting*/
      t: perspective(length'z0→eye) /*create individual 3Dview*/
        rotate3d(x,y,z,<angle>) rotateX?Y?Z(<angle>)
        translate|scale3d(x,y,z) transate|scaleX?Y?Z();
      t-origin: x?y'omitted→50%|x y z(length0d)?;     /*rotate*/
      backface-visibility: visible'd|hidden;    /*rotate 3D≠2D*/
  •perspective:; apply to t-childrens, ›length'r=200big~1000px.
    »p-origin: 50% 50%'d; #only apply to perspective property.
      ›%'border-box, 3values21-moz?webkit-95≠Opera1.4≠gulp.
    »perspective(z-distance:z=0'2Dplane→user) apply→ current tEl
      ›viewPosition uncontrollable, can mixed under p-property.
  •t-origin(→rotate): x?y'omitted→50%| x y z(±length0d)?;
    ›x?y: ±length| ±%'border-box| center'd| <side>.
    ›z-offset: +push|-pull #rotated z0'origin far|to?behind user
  •t: »rotate3d(x,y,z,<angle>); x?y?z-coordinates: ±#'r=-1~1.
      ›rotate clock-wise p→o-axis, Point(x,y,z) Origin(t-origin)
      ›x=y=z=0 valid & #ignored. ›rotate?Z(a)→rotate3d(0,0,1,a)
    ›translate3d(x,y,z); x?y:±length?±%, z:±length.
    »scale3d(x,y,z); x?y?z: ±#1d, -#→pointReflection -z:e/3→3/e.
      ›t: scaleZ(sz) translateZ(z);→ t: translateZ(calc(z*sz));
  •3D axises: ox→+ rotateX(90°)'6→-, oy↓+ rotateY(90°)'6→|,
    ›oz↑user+: rotate?Z(180°)'6→9 translateZ() scaleZ().


★transition: property <duration delay?> timing-function,…?;
  ›apply to all els, ::before?after77≠S, ≠state-pseudo-class.
  ›required statePseudoClass:hover?focuse?active or js.on|event.
  ›onEven: [delay 0→100%] then(onRemoveEvent) [delay 100→0%].
  ›demo: el{color: red; transition: color 2s ease-out;}
         el:hover{color: cyan;}/*transtion happend on un&hover*/
  •t-property: none| all'd| <property-name>, …?;
    ›target p: value(length|#|<color>);, shorthand=its-longhands
  •t-duration: <+time=#s?ms>0d, …?;
  •t-delay: <±time0d>, …?; -#s: start as resumed after played #s
  •t-timing-function: ease'd|-in-out|-in|-out| cubic-bezier()| linear'unChanged| step-start?end| steps(), …?;
    ›ease: slow at start&end, change slow→fast at middle.
    ›ease-in-out: as ease, but unChanged(linear) at middle.
    ›ease-in: slow at start. ›ease-out:slow at end.
    »cubic-bezier(x2,y2,x3,y3): custom curve, x€[0,1], y€R.
      ›Point2(x2,y2) create touching-line with Point1(0,0),
      ›Point3(x3,y3) create touching-line with Point4(1,1).
      ›if y<0, transtions reversed untel point4(1,1).
    »steps(#[, start?end'd|jump-start?end?both?none]?):
      ›#: steps(duration/#) devide duration to fractions.
      ›jump-none(jump #-1): jump just between steps.
      ›jump-both(#+1): jump between steps, transition-start&end.
      ›jump-|start?end(#): between steps, transition-start?end.
    ›step-start?end=steps(1, jump-|start?end).
 *multi-t: transition: list1, list2, …; ›t-*: v1, v2, …;
  »omitting value from shorthand→initial, but in longhands→ refill by order to #all previous list-value's.
    ›ex: t-property: p1, p2, p3, p4, p5, p6, p7;
         t-duration: d1, d2, d3;→ t-d: d1,d2,d3,d1,d2,d3,d1;


★@keyframes <name>{%?from'0%?to'100%{declarations-block}…}
 *animation: none?name <duration delay> timing-function iteration-count direction fill-mode play-state, …?;
  •a-name: none'd|name=[≠0~9][a~Z|0~9|-|_|\escapedCharacter],…?;
  •a-duration?delay?timing-function: <transition-*>;
  •a-iteration-count: #€+Z1d| infinite, …?; ›ex #=.5: [d 0→50%].
  •a-direction: normal'd| reverse| alternate|-reverse, …?;
    ›normal: allways [delay 0→100%] ›reverse: allways [d 100→0%]
    ›alternate'transition: [delay 0→100%] then [delay 100→0%] ….
    ›alternate-reverse: [delay 100→0%] then [delay 0→100%] ….
  •a-fill-mode: none'd| forwards| backwards| both, …?;
    »forwards: sticke last keyframe if animation end.
      ›100% if d:normal, d:alternate;ic:odd, d:a-reverse;ic:even
      ›0% if d:reverse, d:alternate;ic:even, d:a-reverse;ic:odd.
    »backwards: apply first keyframe if delayed(else→none).
      ›0% if d:normal?alternate, 100% if d:reverse?a-reverse.
  •a-play-state: running'd| paused, …?;
    ›onEven pause&resume current frame, without restart from 0%.
 *multi-t: animation: list1, list2, …; ›a-*: v1, v2, …;
  »omitting value from shorthand→initial, but in longhands→ refill by order to #all previous list-value's.
    ›ex: a-name: n1, n2, n3, n4, n5, n6, n7;
         t-duration: d1, d2, d3;→ t-d: d1,d2,d3,d1,d2,d3,d1;