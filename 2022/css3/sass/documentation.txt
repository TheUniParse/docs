… ★ • › » ⁂ ⁑ × ÷ € ← → ↑ ↓ ↔ ↕ ⇆ π ♪ ≠ ≈ ≤ ≥ ± © ✓ ✖ Ø † ⁰ ₱
scss= superset of css, sass= indent syntax style sheet.
★variables: :root{$var-name:value;} s{property: $var-name;}
★nesting: s0{p:v; s01{p:v; s011{p:v} &.a s012{p:v}}}
★partials: _pName.scss≠compiled→css called by @use rule.
 ›@use 'pName'; before any rule≠≈@forward|$var, rel→current.scss
★modules: @use 'src/module'; p:module.$var; @include module.mName; (+funcion)
★@mixin mName($var:iV){p1:$var;…} s{@include mName?($var:v);…}
★%sharedName{p1:v;…}≠compiled→css, s{@extend %sharedName;…}
★operators: +-*%,@use 'sass:math' math.div(600px, 960px) * 100%;

★sass stylesheet stracture:
  •statement0= selector{statement1;statement2}
  •statement= style-rule, property-declaration
 *univarsal statements: used anywhere
  •declaraion: $variable:value
  •flow control: @if @else @each @for @while
  •@error @warn @debug
 *css statements: used anywhere except in @function
  •style rule selector{}
  •css at-rule @media @fon-face @supports @keyframes
  •@include (call @mixin)
  •@at-root
 *top-lvl statements: top-lvl at stylesheet|css statement
  •modyle loads @use//meta.load.css() can be anywhere
  •@import
  •@mixin (definition)
  •@function (definition)
 *other statements:
  •property-declaration used in style-rule or some @at-rule
  •@extend used only in style-rule

 *sassScript: are expression can be in right of 
  •property:expression; $variable:expression; 
  •@function?mixin?if(expression)
 *sassScript can be:
  •number: 12|12px
  •string: 'url'|bold
  •color: #00f|blue
  •boolean: true|false
  •null
  •lists: 1em .5em red|1em Rosemary, sans-serif|[l=end] 
  •maps: ('background': red, 'foreground': pink)
  •can contain &
 *operators
  •== !=
  •+ - * / %
  •< > <= >=
  •and or not
  •string concatenate + - /
  •( )
 *other sassScript=expressions
  •$var
  •function calls: var(--custom-property) nth($list, 1) if()
  •special function: calc() url()
  •parent selector: &
  •!important

★comments: /*!preserve /*Øif-compressed //ØleftLine ///ØsassDoc
★style rules: as css selector{declarations=property:value;} +
•nesting:
  ›s-lists: s0>sa, s0>sb, s1>sa, s1>sb{} = s0,s1{sa,sb{}}
  ›s-combinators: s0>s1{} = s0>{s1{}}| s0{>s1{}}| s0{>{s1{}}}
  »parent&: &=outer-selector, can be after|before|argumentOf s
    s0{s1{ul :is(&, s3):hover{}}}//&=s0 s1
    ›suffix: .a__b--c-d{} = .a{&__b{&--c{&-d{}}}}
    ›in sassScript: s0,s1{parent-selector:&}//&=s0,s1
    ›outside style-rule: & return null(=false)
     @mixin b{#{if(&,'&.a:before','.a:before')}{content:'♪ '}}
      .b{@include c}//.b.a:before{content: '♪ '}
      @include c;//.a:before{content: '♪ '}
    ›unify with another selector://'s0… s4'+'.a'{}=s0… s4.a{}
      @mixin a($s){@at-root #{selector.unify(&,$s)}{@content}}
      .f :valid{
        @include a('[type=tel]'){}//.f [type=tel]:valid{}
        @include a('input:after'){}//.f input:valid:after{}
      }
  »@at-root: remove outer selector, s0{@at-root div{}}//div{}
    ›by default nesting include outer selector even if & used
  »properties: s{border-*} = s{border:{style:solid;size:thin}}
    ›s{margin:1em{left:0}}

•#{interpolation}:
  ›can inject #{sassScript expression} in selector:
    @mixin a($s,$v:' ✖'){&>#{$v1}:after{content:$v}} 
    @include a(':valid',' ✓'); @include a(':invalid');
  ›can mixed with &parent-selector, @at-root, s-function()
  ›can contain #{if()}
  ›can injected as|in propertyName:
    @mixin mName($property,$val,$prefixes){
      @each $prefix in $prefixes{-#{$prefix}-#{$propery}:$val}
      #{$property}: $val}
    .selector{@include mName(background-clip,text,moz webkit)}
  ›can injected as :root{--custom-property: #{$value};}
  »issue: interpolation return unquoted string.
    ›fix: @use 'sass:meta'; :root{--font: #{meta.inspect($f)}}

•propery: can be nested, interpolated, hidden:
  ›@mixin mName($c:false){color:if($c,#0f0,null)}
    s0{@include mName}/*Ø*/ s1{@include mName(true)}/*#0f0*/

•placeholders: (css.class + sass:superPower)
  ›can grouped with other selectors: s0, %placeholder{}
  ›can nest other selectors: %placeholder{p:v;&:hover{}}
  ›called by s{@extent %placeholder;}

•css variables:
  ›declared only inside rules
  ›can have different values on different els: 
    el{p:var(--custom-property, fallback-value)}
  ›updating is value affect with both old|new usages.
  ›
  ›
•sass variables:
  ›can declared anywhere, in|out rules, before|after top-rules.
  ›can contain other variables: $v1: $v2 * $v3;
  »can have only 1 value at time: 
    ›$map: ('key':'value',…)
    ›$list: item1 …|,…|/… or (i1 …|,…|/…) or [i1 …|,…|/…]
  ›updating is value affect just new≠old usages
  ›hyphen=underScore: $var-name=$var_name
  ›!defualt flag used in new-$var|$var:null, else old value used
  »configuring modules: @use 'url' with ($var1:val1,$var2:val2);
    ›$vars must be declared by !default at stylesheet top #lvl.
  ›build-in module variables cannot be modified: 
    @use 'sass:<build-in>'; <build-in>.$var: '≠update';//invalid
  »scope: ›local: declared & accessed just in same block.
    ›global: declared at stylesheet top lvl, accessed anywhere.
  »shadowing: if global $var updated in block, we will creat two scopes, global(unEffected) and its local(updated) shadow.
    ›to assign value globaly from local scope add !global flag.
  ›
  ›

•flow control rules:
  »@else? if not? <expression>{}
    ›@mixin a($a,b){p:v;
      @if $a>$b{} @else if not $a{}@else if string.index($a,' ')
      {} @else {@error 'Unknown value #{$a}.';}}
    ›any value=true including 0|''|()|[], except null=false.
  »@each <variable?,…> in <expression>{}
    ›@each $item in $list{.#{'' + $item}{color:$item}}
    ›@mixin l($list...){@each $i in $list
      {.#{'' + $i}{color:$i}}} @include l(red, green);
    ›@each $a,$b,$c in ([a1 a2 a3],$subList2,(c1,c2,c3))
      {#{$a}:before {color:$b;content:'' + $c + ' '}}
    ›@mixin n($nest...){ @each $a,$b,$c in $nest
      {#{$a}:before{color:$b;content:'' + $c + ' '}}
     }@include n(h1 #fff ★,(h2 #ff0 ▶),(h3,#0f0,»),[h4 cyan ›])
    ›@each $key,$value in $map {##{$key:before{content:$value}}
    ›@mixin m($map...){ @each $k,$v in meta.keywords($map)
      {#{$k}:after{content:' ' + $v}} } @include m($h1:1,$h2:2);
  »@for $i from <expression> to|through <expression>{}
    ›can descent↓ or ascent↑, to=exclude|through=include last #
    ›@for $i from 5 to 10{}     //$i:5→6→7→8→9
    ›@for $i from 5 through 10{}//$i:5→6→7→8→9→10
    ›@for $i from 10 to 5{}     //$i:10→9→8→7→6
    ›@for $i from 10 through 5{}//$i:10→9→8→7→6→5
  »@while <expression>{}
   ?›required math

•@at rules:
  »@function <name>(<args...>){<universal statements>@return}
    ›top-lvl statement
    ›func-name = func_name 
    ›$var:value !global;//discouraged!!
    ›arguments required on call, optional if $var:initialized
      can refer to previous ones ($arg1,$arg2:$arg1*2)
      $args-name must be meanfull for other devs
      can be argument list if last arg: ($arg1,$arg2,$args...)
      meta.keywords() transform ($args...) to map () without $
      pass list on calling func-name(args…)
        $args:(ka:a,kb:b); @debug func($args...);//(ka:a,kb:b)
    ›@return stops function & ignore subsequence code-block
      & return result represedant the called function.
      →r1 @else r2: @function n(a…){@if c{@return r1}@return r2}
    ›other build-in functions module.func()
      funcs: plain css functions: url() *-gradient() …
      custom-functoin: gilpfile.js//sass.render?Sync({})
    ›@function pow($base,$exponent:1){$result:1;
      @for $_ from 1 through $exponent{$result:$result*$base}
      @return $result} .left{left:pow(4,3)*1px}
  »@mixin <name>|<name>(<args…>){<any-statements≠top-lvl>}
    ›indent syntax: =<mixin-name>{} +<mixin-name>;
    ›can encapsulate styles included in style-rule
    ›can encapsulate style-rules included in top-lvl stylesheet?statements
    ›can serve to modify variables.
    ›called by @include <name>|<name>(<args…>)
    ›<mixin-name>=<mixin_name>
    ›arguments: as @function
    »@content block: can include multple @content
      ›can have neighbors styles inside its {}
      ›@mixin name{s{@content}}@include name{/*injected*/}
      ›{@content} recognize only {local-scope variables} not outside its {block} even neighbors from same mixin body
      »pass @mixin ($args…) to @content
        @mixin n($headings...){
          @each $h in $headings{#{$h}:after{@content($h)}}
        };@include n(h1,h2,h3,h4) using ($h){content:'' +$h}

▶★•»›…⚠️💡±×÷²√π⁰≠≈≤≥Ø∞✓✗✖ € ← → ↑ ↓ ⇆♪©†₱
•global functions: hsl()
  ›rgb?a($color, $alpha), last $alpha used: rgb(#0005,1)=#000
  ›if($condition, $return-if-true, $return-if-false)
  »≠recommended: ›map-get?values|keys?has-key|remove?merge
    ›list-separator|is-bracketed|length|index|set-?nth|append|join|zip
    ›un?quote|str-length?index?slice?insert|to-upper?lower-case|unique-id
    ›comparable?unitless?unit|ceil?floor?round?max?min|abs|random?persentage
    ›call?get-function|inspect|keywords|type-of|feature?function??mixin?content?global-?variable-exists

•build-in module:
  »@use 'sass:meta';
   •mixins:
    »load-css('module-url',$with?:null)//@use 'm' with ($v:u,)
      ›@include load-css('path/moduleName',$with:('v':update,…))
      »like @use: ›cannot configurate module alredy loaded.
        ›module loaded only once by @use or meta.load-css()
      »unlike @use: ›used enywhere, even can nest style-rule
        ›unprovide members from loaded module to the current one
        ›url can be unquoted string, $variable, #{interpolation}
   •functions:
    »calc-name?args(calc?clamp?min?max($args…))//'calc?…'|$args…
      ›calc-name(min(1,2,3))//'min' calc-args(min(1,2,3))//1,2,3
    »call(meta.get-function(),$args…)//get-function($args…)
      »get-function($name,$css:false,$module:null)
        ›get-function(n)//refer→ @function defined currently.
        ›get-function(n,true?any)//refer→ plain-css function
        ›get-function(n,false?null,namespace)//build-in|_partial
          required @use 'namespace=build-in|_partial.scss';
          not @include meta.load-css()
      »call($get-function,$args…)//get-function($args…)=result
        ›meta.call(meta.get-function(pow,null,math),3,2)//3^2=9
        ›meta.call(meta.get-function(myFunct,null,myFile),3,2)
          //myFile.myFunc(3,2)=<result>
    »feature-exists($feature)//boolean
      ›global-variable-shadowing ›extend-selector-pseudoclass
      ›units-level-3 ›at-error ›custom-property
    »function-exists($name,$module:null)//boolean
      ›$module:namespace required @use 'namespace'; ≠load-css()
    »mixin-exists($name,$module:null)//boolean
      ›$module:namespace required @use 'namespace'; ≠load-css()
    »content-exists()//boolean
      ›@mixin n{@content;@debug meta.content-exists()}
        @include n;//false     @include n{};//true
      ›Error: content-exists() may only be called within a mixin
    ›variable-exists($name:≠$)//boolean(current-scope)
    »global-variable-exists($name:≠$,$module:null)//boolean
      ›$module:namespace required @use 'namespace'; ≠load-css()
      ›global-variable-exists(pi,math)//true
      ›global-variable-exists(myVar,myFile)//true
        »module-functions()
    »module-functions($module)//map
      ›$module:namespace required @use 'namespace'; ≠load-css()
      ›module-functions(myFile);
        //('myFunc': get-function('myFunc'))
      ›module-functions(meta);
        //('type-of': get-function('type-of'), …)
      ›call(map.get(meta.module-functions(math),pow),3,2)//3^2=9
    »module-variables($module)//map
      ›$module:namespace required @use 'namespace'; ≠load-css()
      ›module-variables(myFile);//("myVar": v)
      ›module-variables(meta);//()
      ›module-variables(math);
        //('e': 2.7182818285, 'pi': 3.1415926536)
    ›keywords($args:(ignored,$varName:v,…))//(varName:v,…)
    »inspect($value)//$value regardless if valid css or not
      ›@debug 'str';/*str*/ @debug meta.inspect('str');//'str'
    »type-of($value)//type-of $value
      ›null→null ›±#|±#unit|math.tan(±π/2)=±Infinity→number
      ›true|false→bool ›unquoted|'quoted'→string
      ›red|#f00|rgb(255,0,0)|hsl(0,100%,50%)→color
      ›e s…|(e s…|e1,|Ø)|[e s…|e1|Ø]→list
      ›@mixin?function n($args...){}→arglist
      ›(k:v,…)|meta.keywords($args:())→map
      ›get-function($name)→function
  »@use 'sass:math';
    »variables: ›math.$e//Euler#=2.718… ›math.$pi//π=3.14…
    »compatibleUnits $all...: <angle:±#rad?grad?deg?turn>
      <absoluteLength:±#in?cm?mm?q?pt?pc?px> <time:±#s?ms>
      <sameUnit:±#rem?em?ch?ex?%?vw?vh?vmin?vmax?dpi?ppi?x?any…>
      ›all math.funcs return first compatible ±#unit
   •Units funcs: ›is-unitless(±#|±#anyUnit)//boolean
    ›unit(±#|±#anyUnit)//''|'anyUnit'
    »compatible($arg1,$arg2)//boolean
      ›both:±#unitless|compatible//true both:uncompatible//false
      ›issue: compatible(±#,±#anyUnite)//true
   •Bound'ing funcs:
    »min?max($l...)//small?biggest, all$i:±#unitless?compatible
      ›issue: min?max(#...,$compatible...)
        //small?biggest #|$compatible=use1stUnit, #…rel→1stUnit
    »clamp($min,$number,$max)//all must be ±#unitless?compatible
      ›clamp($min,≥$number|$number≥,$max)//$min|$max
      ›clamp($min,<$number<,$max)//$number
    »ceil?floor(#.f)//#+1?# ›round(#.f≥5|#.f<5)//#+1|#
      ›ceil?floor(-#.f)//-#?-#-1 ›round(-#.f≥5|<5)//-#-1|-#
      ›fraction≠0, # can be either unitless or with #anyUnit.
   •Distance funcs: ›abs(±#|±#anyUnit)//absolute: +#|+#anyUnit
    »hypot($lengths...)//√($l1²+…) all$l…:±#?±#compatible=use1st
      ›hypot($ox)//1D:$om(x)=√($ox²)=math.abs($ox)
      ›hypot($ox,$oy)//2D:$om(x,y)=√($ox²+$oy²)
      ›hypot($ox,$oy,$oz)//3D:$om(x,y,z)=√($ox²+$oy²+$oz²)
   •Exponential funcs:
    »sqrt(+#)//squareRoot:pow(#,.5)=√# √+∞→∞slow ›sqrt(-#)//NaN 
    »pow($base,$exp)=$result ›log($result:+#,$base:null)=$exp
      »pow($base:±#,$exponent:±#)//power(^carat)
        ›pow(-#,$exp:odd)//-… ›pow(-#,$exp:even)//+…
        ›pow(+#,$exp:]-1,0[U]0,1[)//(1/$exp)√#| √-#→NaN
        ›pow(±#,$exp:[1,+∞[)//±#^$exp ›pow(±#,$exp:0)//1
        ›pow(±#,$exp:]-∞,-1])//1÷(±#^math.abs($exp))
        »pow(math.$e,±x)//e^-∞→0 e^-1=1/e e^0=1 e^1=e e^+∞→∞fast
      »log($result:+#, $base?:null=math.$e)//ln=logarithmNatural
        ›log($b^#,$b)//# ›log(1)//0
        ›log(0,$b:]1,∞[)//-Infinity ›log(→+∞,$b:]1,∞[)//→+∞slow
        ›log(0,$b:]0,1[)//Infinity ›log(→+∞,$b:]0,1[)//→-∞slow
        »ln-#=NaN ln0=-Infinity ln0.f=-# ln1=0 lne=1 ln+∞→∞slow
   •Trigonometric funcs:
    »in right triangle90⁰: hypotenuse=√(adjacet²+opposite²)
      ›soh cah toa: Cosine=Adj/Hyp Sine=Opp/Hyp Tangent=Opp/Adj
    »cos?sin?tan(±#=rad|<angle>)//$result:±# (k€Z)
      ›tan(X≠π/2+kπ)=sinX/cosX ›cos-X=cosX sin?tan-X=-sin?tanX 
      ›cos(2kπ± 0|π/6|π/4|π/3|π/2|π)=1|√3/2|√2/2|1/2|0|-1
      ›sin(2kπ± 0|π/6|π/4|π/3|π/2|π)=(±) 0|1/2|√2/2|√3/2|1|0
      ›tan(kπ± 0|π/6|π/4|π/3|π/2)=(±) 0|√3/3|1|√3|→Infinity'fast
      ›cos²X+sin²X=1 ›cos2X=cos²X-sin²X sin2X=2cosX.sinX
      ›tan(±X+kπ)=±tanX cos?sin(2kπ+ X|X+π)=(+|-)cos?sinX
      ›cos?sin(-X+π/2)=other(X) cos(X+π/2)=-sinX sin(X+π/2)=cosX
      ›cosA±B=cosA.cosB(-±)sinA.sinB sinA±B=sinA.cosB±sinB.cosA
      ›cos(2kπ±X)=Y sin(2kπ+ X|-X+π)=Y tan(kπ+X)=Y
    »acos?asin?atan($result:±#)//<angle:±#deg> (arcus funcs)
      ›acos?asin($result:[-1,1])//else:NaNdeg
    »atan2($y:±#|±#Unite,$x:±#|±#SameUnit)//<angle:±#deg>
      ›atan2(sinx,cosx)
   •other funcs:
    »div($dividend,$divisor)//$quotient:$devidend/$divisor
      ›div(6a,2|6,2a|6a,2b)//3a|3a^-1|3a/b
      ›both unitless|compatible//±#
    ›percentage(±#€Z)//±#*100%
    »random($limit?:null)
      ›random(Ø| #€N≠0| $limit:#≥1€N)//]0,1[| #| [1,$limit]€N
  »@use 'sass:string';
    »issue:all sass buildIn.funcs return unquoted string
      ›fix: meta.inspect(string.func(/**/))
    ›length($string)//#
    »index($string,$subString)//first $subString letter nth|null
      ›index('hello world',world);//7
      ›index('hello world',undefined);//null
    »slice($str, ±#startAt, ±#endAt?:-1D)//return slice of $str
      ›slice('hello world',-5)//'world'
      ›slice('I love you',3,6)//'love'
    »insert($string, $insert, ±#)//insert string on ±index
      ›insert('I\'am good','not ',-5)//"I'am not good"
      ›insert('hello',' world',100);//'hello world'
      ›insert('world','hello ',-100);//'hello world'
    ›quote(str|'str')//'str' ›unquote(str|'str')//str
    ›to-upper-case('Bill')//'BILL' ›to-lower-case(Bill)//bill
    ›unique-id()//ufw2ymw(≠ ufw2ybm ≠ …)
  »@use 'sass:color';
    ›red?green?blue|alpha|hue($c)//0~255|0~1|0~360deg
    ›saturation?lightness?whiteness?blackness($c)//0~100%
    »change($c,$red:null,$green:null,$blue:null,$hue:null,$saturation:null,$lightness:null,$whiteness:null,$blackness:null,$alpha:null)
      ›error: don't Enter at once all args of rgb?hsl?hwb()
      ›$red?green?blue:0~255 ›$hue:(-360~360 +360k)deg?//k€Z
      ›$saturation?lightness?whiteness?blackness:0~100% 
      ›$alpha:0~1
    »adjust(<color.change args>)
      ›error: don't Enter at once all args of rgb?hsl?hwb()
      ›$red?green?blue:-255~255 ›$hue:(-360~360 +360k)deg?//k€Z
      ›$saturation?lightness?whiteness?blackness:-100~100%
      ›$alpha:-1~1
    »invert($c,$weight:0~100%d|0~100)//-(#%)$c
      ›invert($c,0|50|100)//$c|gray|-$c
      ›invert(hsl(334,100%,53%,.2));//hsl(154,100%,47%,.2)
    »complement()
    »mix()
    »scale()
    »hwb()
    »ie-hex-str()
    »grayscale()
▶★•»›…⚠️💡±×÷²√π⁰≠≈≤≥Ø∞✓✗✖ € ← → ↑ ↓ ⇆♪©†₱
  »@use 'sass:list';
    »issue invaid-lists(currently): e1/… (e1/…) [# …|e1,…|e1/…] 
      ›fix→sass2: calc(/)=math.dev(), /separator=list.slash()
    »$list: elem $s …| ($l|k:V,…|e1,|Ø)| [$l|e1|Ø]; $s:&#32|,|/;
      ›@mixin a($l...){@each $e in $l{.#{'' + $e}{color:$e}}}
      ›@mixin n($nest...){ @each $a,$b,$c in $nest
        {#{$a}:before {color:$b; content:'' + $c + ' '}}
      }@include n(h1 #fff ★,(h2 #ff0 ▶),(h3,#0f0,»),[h4 cyan ›])
      ›can use list.index() in: @if not?| @else if not?| if()
      ›immutablility: all list.funcs() return #copy of org $list
    ›is-bracketed($list)//boolean
    ›separator($list)//space?comma?slash
    »length($list)//#
      ›length((k1:v1,k2:v2))//2
    »index($list,en)//n (index start counte from 1≠0)
      ›index((ka:va,kb:vb), kb vb)//2
      ›index(e1 e2 e2 e2 e3,e2)//2 (index of first same element)
      ›index((e1,e2),eUndefined)//null
    »nth($list,±#)//element.nth(±#)
      ›list.nth((k1:v1,k2:v2,k3:v3,k4:v4),-2);//k3 v3
    »set-nth($list,±#,$v)//return $list copy & replace e±#→$v
      ›set-nth((k1:v1,k2:v2),-1,ku update)//k1 v1,ku update
      ›set-nth(e1 e2,3,update)//Error: $n: Invalid index
    ›slash(e1,…)//e1/… ›slash(e1 e2,e3 e4)//e1 e2/e3 e4
    »append($list,$v,$separator?:auto'd|space=d1|comma|slash)
      ›append(e1 e2,e3,$separator:$s)//e1 $s e2 $s e3
      ›append(($l),en,$separator:$s)//e1 $s … $s en
      ›append([$l],en,$separator:$s)//[e1 $s … $s en]
      ›append((k:v,…),kn vn,$separator:$s)//k v $s … $s kn vn
      ›append((k:v,…),kn vn,$separator:space)//(k v) (…) (kn vn)
    »join($list1,$list2,$separator?,$bracketed?:auto|true|false)
      ›auto'd: $separator=$l1,$l2,space $bracketed=$l1,false
    »zip($list1,…)//$list=$subList1,…
      ›return: comma-separator $list, space-separator $subLists
      ›$sublists nth = smallest list.length($list#)
      ›zip(a1 a2,(b1,b2,b3),[c1 c2 c3]) //a1 b1 c1, a2 b2 c2
  »@use 'sass:map';
    »$map:(<expression>:<expression>, …);
      ›(unique-key:associated-value) can be empty ()
      ›recommended to quote 'keys', avoid confuse with colorName
      ›immutablility: all map.funcs() return #copy of org $map
      ›@each $k,$v in $map {.#{'' + $k}:before{content:$v}}
      ›@mixin add($k,$v){$map:map.merge($map,($k,$v)) !global;}
      ›@mixin m($m...){ @each $k,$v in meta.keywords($m)
        {#{$k}:after{content:' ' + $v}}}@include m($h1:1,$h2:2);
    »keys((k1:v1, k2:v2, k3:v3))//k1,k2,k3
      ›keys((k:(ka:va,kb:vb), k1:v1))//k,k1
    »has-key((k:v), k1)//false
      ›has-key((k: (ka:va)), k,ka)//true
    »values((k1:v1, k2:v2, k3:v3))//v1,v2,v3
      ›values((k:(ka:va,kb:vb), k1:v1))//(ka:va,kb:vb),v1
    »get((key:value),key)//value
      ›get((k:(ka:(ka1:va1))), k,ka,ka1)//va1
      ›get((ka:va), kb)//null
    »set((k:v),k,update)//(k:update)
      ›set((k0: (k:v)), k0,k,update)//(k0: (k:update))
      ›set((k:v),kPlus,vPlus)//(k:v, kPlus:vPlus)
    »remove((k1:v1, k2:v2, k3:v3), k2, k3, kIgnored)//(k1:v1)
      ›deep-remove((k:(ka:va,krm:vrm)), k,krm)//(k: (ka:va))
    »merge((k:v,k1:v1),(k:update,k2:v2))//(k:update,k1:v1,k2:v2)
      ›merge((k0:(k:v)), k0,k,(ku:update))//(k0:(k:(ku:update)))
      ›merge((k0:(k:v)), k0,(ka:va))//(k0: (k:v, ka:va))
      ›deep-merge((k:(ka:va)),(k:(kb:vb)))//(k:(kb:kb,ka:va))
  »@use 'sass:selector';
    ›.unify: s0 s1{@at-root #{selector.unify(&,'.child')}{/**/}}
    ›
    ›
    ›
    ›

•terminal:
  ›@debug <expression>//path/file.scss:#(line) Debug: <combile>
  ›@error <expression>: stops compiling, in @mixin|function
    //Error: <compile>
    //       |
    //#(line)| …@include mName();…
    //       |
   //path/file.scss #:#(line:column) root stylesheet(or mName())
  ›@warn <expression>: don't stops compiling, in @mixin|function
    //Warning: <compile>
    //path/file.scss #:#(@warn) mname()
    //path/file.scss #:#(@include) root stylesheet

▶★•»›…⚠️💡±×÷²√π⁰≠≈≤≥Ø∞✓✗✖ € ← → ↑ ↓ ⇆♪©†₱